/* Generated by re2c 1.2.1 on Sun Nov  3 18:19:20 2019 */
#line 1 "expr_lexer.re"
#include <istream>
#include <cstring>
#include <cstdio>
#include <iostream>

#include "expr_lexer.h"

#define YYMAXFILL 12


Token ExprLexer::getNextToken(){
    #define YYFILL(n) do { \
        FillStatus st = ctx.fill(n); \
        if(st == FillStatus::Eof){ \
            return tkEof(); \
        } else if(st == FillStatus::Error){ \
            return tkError(); \
        } else { \
            break; \
        } \
    } while(0); \

    while(1){
        ctx.tok = ctx.cur;
        char *YYMARKER;

        #line 35 "expr_lexer.re"

            

            if(state == 0) { goto input;}
            else if(state == 1){ goto lineComment;}
            else if(state == 2){ goto blockComment;}
        input:
         
#line 39 "expr_lexer.cpp"
{
	char yych;
	if ((ctx.lim - ctx.cur) < 12) YYFILL(12);
	yych = *ctx.cur;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case ' ':	goto yy6;
	case '(':	goto yy9;
	case ')':	goto yy11;
	case '*':	goto yy13;
	case '+':	goto yy15;
	case '-':	goto yy17;
	case '/':	goto yy19;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy21;
	case ';':	goto yy24;
	case '<':	goto yy26;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'g':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	case 'E':	goto yy30;
	case 'M':	goto yy31;
	case 'S':	goto yy32;
	case 'e':	goto yy33;
	case 'f':	goto yy34;
	case 'h':	goto yy35;
	case 's':	goto yy36;
	default:	goto yy4;
	}
yy2:
	++ctx.cur;
#line 47 "expr_lexer.re"
	{ return tkEof(); }
#line 125 "expr_lexer.cpp"
yy4:
	++ctx.cur;
yy5:
#line 45 "expr_lexer.re"
	{ return tkError(); }
#line 131 "expr_lexer.cpp"
yy6:
	++ctx.cur;
	if (ctx.lim <= ctx.cur) YYFILL(1);
	yych = *ctx.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy6;
	default:	goto yy8;
	}
yy8:
#line 46 "expr_lexer.re"
	{ continue ; }
#line 144 "expr_lexer.cpp"
yy9:
	++ctx.cur;
#line 52 "expr_lexer.re"
	{ std::cout << "OPENPAR" << std::endl;return makeToken(Token::OpenPar); }
#line 149 "expr_lexer.cpp"
yy11:
	++ctx.cur;
#line 53 "expr_lexer.re"
	{ std::cout << "CLOSEPAR" << std::endl;return makeToken(Token::ClosePar); }
#line 154 "expr_lexer.cpp"
yy13:
	++ctx.cur;
#line 50 "expr_lexer.re"
	{ std::cout << "MUL" << std::endl;return makeToken(Token::OpMul); }
#line 159 "expr_lexer.cpp"
yy15:
	++ctx.cur;
#line 48 "expr_lexer.re"
	{ std::cout << "SUMA" << std::endl; return makeToken(Token::OpAdd); }
#line 164 "expr_lexer.cpp"
yy17:
	++ctx.cur;
#line 49 "expr_lexer.re"
	{ std::cout << "RES" << std::endl;return makeToken(Token::OpSub); }
#line 169 "expr_lexer.cpp"
yy19:
	yych = *++ctx.cur;
	switch (yych) {
	case '*':	goto yy37;
	case '/':	goto yy39;
	default:	goto yy20;
	}
yy20:
#line 51 "expr_lexer.re"
	{ std::cout << "DIV" << std::endl;return makeToken(Token::OpDiv); }
#line 180 "expr_lexer.cpp"
yy21:
	++ctx.cur;
	if (ctx.lim <= ctx.cur) YYFILL(1);
	yych = *ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy21;
	default:	goto yy23;
	}
yy23:
#line 64 "expr_lexer.re"
	{ std::cout << "NUM" << std::endl;return makeToken(Token::Number); }
#line 201 "expr_lexer.cpp"
yy24:
	++ctx.cur;
#line 54 "expr_lexer.re"
	{ return makeToken(Token::Semicolon); }
#line 206 "expr_lexer.cpp"
yy26:
	yych = *++ctx.cur;
	switch (yych) {
	case '-':	goto yy41;
	default:	goto yy5;
	}
yy27:
	++ctx.cur;
	if (ctx.lim <= ctx.cur) YYFILL(1);
	yych = *ctx.cur;
yy28:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy29;
	}
yy29:
#line 65 "expr_lexer.re"
	{ std::cout << "ID" << std::endl; return makeToken(Token::Ident); }
#line 286 "expr_lexer.cpp"
yy30:
	yych = *++ctx.cur;
	switch (yych) {
	case 's':	goto yy43;
	default:	goto yy28;
	}
yy31:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy44;
	default:	goto yy28;
	}
yy32:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy45;
	default:	goto yy28;
	}
yy33:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy47;
	default:	goto yy28;
	}
yy34:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy48;
	default:	goto yy28;
	}
yy35:
	yych = *++ctx.cur;
	switch (yych) {
	case 'a':	goto yy49;
	default:	goto yy28;
	}
yy36:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy50;
	default:	goto yy28;
	}
yy37:
	++ctx.cur;
#line 43 "expr_lexer.re"
	{state = 2; continue;}
#line 333 "expr_lexer.cpp"
yy39:
	++ctx.cur;
#line 44 "expr_lexer.re"
	{state = 1; continue;}
#line 338 "expr_lexer.cpp"
yy41:
	++ctx.cur;
#line 62 "expr_lexer.re"
	{ std::cout << "ASSIGN" << std::endl;return makeToken(Token::Assign); }
#line 343 "expr_lexer.cpp"
yy43:
	yych = *++ctx.cur;
	switch (yych) {
	case 'c':	goto yy51;
	default:	goto yy28;
	}
yy44:
	yych = *++ctx.cur;
	switch (yych) {
	case 'e':	goto yy52;
	default:	goto yy28;
	}
yy45:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy46;
	}
yy46:
#line 55 "expr_lexer.re"
	{ std::cout << "IF" << std::endl;return makeToken(Token::If); }
#line 426 "expr_lexer.cpp"
yy47:
	yych = *++ctx.cur;
	switch (yych) {
	case 't':	goto yy53;
	default:	goto yy28;
	}
yy48:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy54;
	default:	goto yy28;
	}
yy49:
	yych = *++ctx.cur;
	switch (yych) {
	case 'g':	goto yy55;
	default:	goto yy28;
	}
yy50:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy56;
	default:	goto yy28;
	}
yy51:
	yych = *++ctx.cur;
	switch (yych) {
	case 'r':	goto yy57;
	default:	goto yy28;
	}
yy52:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy58;
	default:	goto yy28;
	}
yy53:
	yych = *++ctx.cur;
	switch (yych) {
	case 'o':	goto yy59;
	default:	goto yy28;
	}
yy54:
	yych = *(YYMARKER = ++ctx.cur);
	switch (yych) {
	case ' ':	goto yy60;
	default:	goto yy28;
	}
yy55:
	yych = *++ctx.cur;
	switch (yych) {
	case 'a':	goto yy62;
	default:	goto yy28;
	}
yy56:
	yych = *++ctx.cur;
	switch (yych) {
	case 'o':	goto yy64;
	default:	goto yy28;
	}
yy57:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy66;
	default:	goto yy28;
	}
yy58:
	yych = *++ctx.cur;
	switch (yych) {
	case 't':	goto yy67;
	default:	goto yy28;
	}
yy59:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy68;
	default:	goto yy28;
	}
yy60:
	yych = *++ctx.cur;
	switch (yych) {
	case 'm':	goto yy69;
	case 's':	goto yy70;
	default:	goto yy61;
	}
yy61:
	ctx.cur = YYMARKER;
	goto yy29;
yy62:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy63;
	}
yy63:
#line 60 "expr_lexer.re"
	{ std::cout << "DO" << std::endl;return makeToken(Token::Do); }
#line 585 "expr_lexer.cpp"
yy64:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy65;
	}
yy65:
#line 57 "expr_lexer.re"
	{ std::cout << "ELSE" << std::endl;return makeToken(Token::Else); }
#line 656 "expr_lexer.cpp"
yy66:
	yych = *++ctx.cur;
	switch (yych) {
	case 'b':	goto yy71;
	default:	goto yy28;
	}
yy67:
	yych = *++ctx.cur;
	switch (yych) {
	case 'r':	goto yy72;
	default:	goto yy28;
	}
yy68:
	yych = *++ctx.cur;
	switch (yych) {
	case 'c':	goto yy73;
	default:	goto yy28;
	}
yy69:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy74;
	default:	goto yy61;
	}
yy70:
	yych = *++ctx.cur;
	switch (yych) {
	case 'i':	goto yy75;
	default:	goto yy61;
	}
yy71:
	yych = *++ctx.cur;
	switch (yych) {
	case 'a':	goto yy77;
	default:	goto yy28;
	}
yy72:
	yych = *++ctx.cur;
	switch (yych) {
	case 'a':	goto yy79;
	default:	goto yy28;
	}
yy73:
	yych = *++ctx.cur;
	switch (yych) {
	case 'e':	goto yy80;
	default:	goto yy28;
	}
yy74:
	yych = *++ctx.cur;
	switch (yych) {
	case 'e':	goto yy81;
	default:	goto yy61;
	}
yy75:
	++ctx.cur;
#line 58 "expr_lexer.re"
	{std::cout << "ENDIF" << std::endl; return makeToken(Token::EndIf); }
#line 715 "expr_lexer.cpp"
yy77:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy78;
	}
yy78:
#line 63 "expr_lexer.re"
	{ std::cout << "PRINT" << std::endl;return makeToken(Token::Print); }
#line 786 "expr_lexer.cpp"
yy79:
	yych = *++ctx.cur;
	switch (yych) {
	case 's':	goto yy82;
	default:	goto yy28;
	}
yy80:
	yych = *++ctx.cur;
	switch (yych) {
	case 's':	goto yy84;
	default:	goto yy28;
	}
yy81:
	yych = *++ctx.cur;
	switch (yych) {
	case 'n':	goto yy86;
	default:	goto yy61;
	}
yy82:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy83;
	}
yy83:
#line 59 "expr_lexer.re"
	{ std::cout << "WHILE" << std::endl;return makeToken(Token::While); }
#line 875 "expr_lexer.cpp"
yy84:
	yych = *++ctx.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy27;
	default:	goto yy85;
	}
yy85:
#line 56 "expr_lexer.re"
	{ std::cout << "THEN" << std::endl;return makeToken(Token::Then); }
#line 946 "expr_lexer.cpp"
yy86:
	yych = *++ctx.cur;
	switch (yych) {
	case 't':	goto yy87;
	default:	goto yy61;
	}
yy87:
	yych = *++ctx.cur;
	switch (yych) {
	case 'r':	goto yy88;
	default:	goto yy61;
	}
yy88:
	yych = *++ctx.cur;
	switch (yych) {
	case 'a':	goto yy89;
	default:	goto yy61;
	}
yy89:
	yych = *++ctx.cur;
	switch (yych) {
	case 's':	goto yy90;
	default:	goto yy61;
	}
yy90:
	++ctx.cur;
#line 61 "expr_lexer.re"
	{ std::cout << "ENDWHILE" << std::endl;return makeToken(Token::EndWhile); }
#line 975 "expr_lexer.cpp"
}
#line 67 "expr_lexer.re"


     lineComment:
        
#line 982 "expr_lexer.cpp"
{
	char yych;
	if (ctx.lim <= ctx.cur) YYFILL(1);
	yych = *ctx.cur;
	switch (yych) {
	case '\n':	goto yy96;
	default:	goto yy94;
	}
yy94:
	++ctx.cur;
#line 72 "expr_lexer.re"
	{state = 1; continue;}
#line 995 "expr_lexer.cpp"
yy96:
	++ctx.cur;
#line 71 "expr_lexer.re"
	{lineno++; state = 0; continue;}
#line 1000 "expr_lexer.cpp"
}
#line 73 "expr_lexer.re"

        blockComment:
        
#line 1006 "expr_lexer.cpp"
{
	char yych;
	if ((ctx.lim - ctx.cur) < 2) YYFILL(2);
	yych = *ctx.cur;
	switch (yych) {
	case '\n':	goto yy102;
	case '*':	goto yy104;
	default:	goto yy100;
	}
yy100:
	++ctx.cur;
yy101:
#line 78 "expr_lexer.re"
	{state = 2; continue;}
#line 1021 "expr_lexer.cpp"
yy102:
	++ctx.cur;
#line 77 "expr_lexer.re"
	{lineno++; state = 2; continue;}
#line 1026 "expr_lexer.cpp"
yy104:
	yych = *++ctx.cur;
	switch (yych) {
	case '/':	goto yy105;
	default:	goto yy101;
	}
yy105:
	++ctx.cur;
#line 76 "expr_lexer.re"
	{state = 0; continue;}
#line 1037 "expr_lexer.cpp"
}
#line 80 "expr_lexer.re"

        
    }
}

ExprLexer::Context::Context(std::istream &in): in(in){
    buf = new char[SIZE+YYMAXFILL];
    lim = buf+SIZE;
    cur = lim;
    tok = lim;
    eof = false;
}

ExprLexer::FillStatus ExprLexer::Context::fill(size_t need){
    if (eof) {
        return FillStatus::Eof;
    }
    const size_t free = tok - buf;
    if (free < need) {
        return FillStatus::Error;
    }

    memmove(buf, tok, lim - tok);
    lim -= free;
    cur -= free;
    tok -= free;
    in.read(lim,free);
    lim += in.gcount();
    printf("LIM: %s\n", lim);
    //std::cout << "LIM: "<< lim << std::endl;
    if (lim < buf + SIZE) {
        eof = true;
        memset(lim, 0, YYMAXFILL);
        lim += YYMAXFILL;
    }
    return FillStatus::Ok;
}




